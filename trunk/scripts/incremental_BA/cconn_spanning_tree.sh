#!/bin/sh

# this takes files generated by graph_get_cam_connectivity.sh, turns
# them into a spanning tree and generates camera insertion order.

# note that this uses string sorting in place of number sorting
# to maintain compatibility with older versions of gawk and therefore
# it is limited to graphs with 2^32-1 cameras. should be ok till the
# end of the decade. the future generations need to increase int_max
# and change occurences of %08x to a higher number of digits.

if [[ $# -ne 1 && $# -ne 2 ]]; then
	>&2 echo 'error: use ./cconn_spanning_tree.sh <camera connectivity graph file> [traverse order]'
	>&2 echo 'where <traverse order> is 0 for DFS, 1 for BFS and 2 for BFS with priority queue (default BFS)'
	exit
fi

if [ $# -eq 2 ]; then
	TRAV_ORDER=$2
else
	TRAV_ORDER=1
fi

gawk -v traverse_order=$TRAV_ORDER 'BEGIN {
		num_cameras = 0;
		nnz = 0;

		#traverse_order = 2;
		# 0 = DFS, 1 = BFS, 2 = BFS using a priority queue

		int_max = 2147483647;
		# hack - want to have the sort by weight stable and for that, the edge order is a part
		# of the key - only we want to have them in descending order so we need to negate the
		# edge ids so that lexicographical sort sorts them last to first (note that if there
		# are more edges, nothing serious will happen, the order will just not be preserved anymore)
	}
	{
		if($1 == "CAM") {
			cam_ids[++ num_cameras] = $2;
			cam_groups[$2] = num_cameras;
			print $0; # echo these lines to the output
		}
		# keep a list of camera index mapping from graph to one-based indices

		if($1 == "EDGE") {
			++ nnz;
			edges[nnz] = $2 "@" $3;
			edge_weights[sprintf("%08x@%d", $4, int_max - nnz)]; # convert weights to 32-bit hex number so that they could be sorted as strings (meh)
		}
		# keep a list of edges, ready to be ordered by weight
	}
	END {
		tree_size = 0;
		span = 0;

		n = asorti(edge_weights); # sort the edge ids by weight
		for(i = n; i > 0; -- i) { # go by decreasing weight: get a maximum weight spanning tree
			#print edge_weights[i]; # debug
			split(edge_weights[i], weight_eid, "@"); # separate weight and edge id
			#print int_max - weight_eid[2]; # debug
			eid = int_max - weight_eid[2];
			#print eid ", " edges[eid]; # debug
			split(edges[eid], edge_id, "@"); # get edge

			group0 = cam_groups[edge_id[1]];
			group1 = cam_groups[edge_id[2]];
			# get camera groups

			#print edge_weights[i] ": " edge_id[1] " -> " edge_id[2] " (" group0 ", " group1 ")"; # debug

			if(group0 == group1)
				continue;
			# in case both cameras are in the same group then this edge is not spanning

			if(group0 > group1) {
				tmp = group0;
				group0 = group1;
				group1 = tmp;

				tmp = edge_id[1];
				edge_id[1] = edge_id[2];
				edge_id[2] = tmp;
			}
			# sort the group ids, should end up putting all the vertices in group 1 that way

			spanning_tree[++ tree_size] = edge_id[1] "@" edge_id[2];
			# add edge to the spanning tree

			degree = cam_degree[edge_id[1]] = cam_degree[edge_id[1]] + 1;
			cam_adjacent[edge_id[1], degree] = edge_id[2];
			degree = cam_degree[edge_id[2]] = cam_degree[edge_id[2]] + 1;
			cam_adjacent[edge_id[2], degree] = edge_id[1];
			# form camera adjacency information

			print "ST_EDGE " edge_id[1] " " edge_id[2];
			# include the spanning tree in the output, orient the edges so that the cameras could come out approximately sorted

			span = 0;
			for(c in cam_groups) {
				if(cam_groups[c] == group0)
					++ span;
				else if(cam_groups[c] == group1) {
					cam_groups[c] = group0;
					++ span;
				}
			}
			# rewrite group ids of cameras that were linked by this edge

			if(span == num_cameras)
				break;
		}
		# build a spanning tree

		if(span != num_cameras)
			print "error: the graph is not connected: span " span " / " num_cameras " cameras" > "/dev/stderr";
		# make sure we have the spanning tree

		visited_num = 0;
		first_cam_num = 0; # used for BFS only
		next_cam_num = first_cam_num + 1;
		next_cams[next_cam_num] = cam_ids[1]; # a stack / queue
		for(; next_cam_num > first_cam_num;) {
			if(traverse_order == 0) {
				cur_cam = next_cams[next_cam_num];
				delete next_cams[next_cam_num];
				-- next_cam_num;
				# "pop"
			} else if(traverse_order == 1) {
				++ first_cam_num;
				cur_cam = next_cams[first_cam_num];
				delete next_cams[first_cam_num];
				# "dequeue"
			} else {
				cur_cam = next_cams[++ first_cam_num];
				min_cam_idx = first_cam_num;
				for(i = first_cam_num + 2; i <= next_cam_num; ++ i) {
					if(cur_cam > next_cams[i]) {
						cur_cam = next_cams[i];
						min_cam_idx = i;
					}
				}
				# find the camera with the minimum index

				for(i = min_cam_idx; i > first_cam_num; -- i)
					next_cams[i] = next_cams[i - 1];
				delete next_cams[first_cam_num];
				# if taking a camera from the middle, shift the queue and delete the first (now unused) element

				# this uses a "priority queue" which always dequeeus the camera with the lowest id
			}

			if(cur_cam in visited) {
				print "warning: camera " cur_cam " already visited" > "/dev/stderr";
				continue;
			}
			# this should not generally happen since it is a tree and not a graph

			print "ORDER " cur_cam;
			# output the id of the next camera

			visited[cur_cam];
			++ visited_num;
			# mark as visited

			degree = cam_degree[cur_cam];
			split("", adjacent_cams); # clear the adjacent_cams array
			for(i = 1; i <= degree; ++ i) {
				adj = cam_adjacent[cur_cam, i];
				if(!(adj in visited)) {
					#print "open " adj; # debug
					adjacent_cams[sprintf("%010d", adj)]; # gather only unvisited ones
				}
			}
			degree = asorti(adjacent_cams); # can have lower degree because we didnt potentially insert all the adjacent cameras
			# read adjacent cameras and sort them by increasing id to guarantee the same
			# spanning trees in different versions of gawk (the associative arrays may
			# use different hash functions and may therefore have different natural order
			# of elements)

			if(traverse_order == 0) {
				for(i = degree; i > 0; -- i) {
					#print "push " (adjacent_cams[i] + 0) " (" adjacent_cams[i] ")"; # debug
					next_cams[++ next_cam_num] = adjacent_cams[i] + 0;
				}
				# "push" more cameras (reverse order, will be popped also reverse)
			} else {
				for(i = 1; i <= degree; ++ i) {
					#print "push " (adjacent_cams[i] + 0) " (" adjacent_cams[i] ")"; # debug
					next_cams[++ next_cam_num] = adjacent_cams[i] + 0;
				}
				# "enqueue" more cameras
			}
		}
		# DFS / BFS

		if(visited_num != num_cameras)
			print "error: graph traversal failed: visited " visited_num " / " num_cameras " cameras" > "/dev/stderr";
		# make sure we have visited all
	}

	function TreeRoot()
	{
		# does not work very well, the spanning tree is undirected, hard to generate one with only a single root

		for(i = 1; i <= num_cameras; ++ i)
			tree_root[cam_ids[i]] = 1;
		for(e in spanning_tree) {
			split(spanning_tree[e], cam_id, "@");
			tree_root[cam_id[2]] = 0; # the edge goes from cam_id[1] -> cam_id[2]. cam_id[2] therefore cant be the root of the spanning tree
		}
		num_roots = 0;
		for(i = 1; i <= num_cameras; ++ i) {
			if(tree_root[cam_ids[i]] == 1) {
				++ num_roots;
				print "ST_TREE_ROOT " cam_ids[i];
			}
		}
		# find spanning tree root
	}' $1
