CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
IF(COMMAND cmake_policy)
	CMAKE_POLICY(SET CMP0003 NEW)
ENDIF(COMMAND cmake_policy)

PROJECT(SLAM_plus_plus)

# dont ask me about those ...
MARK_AS_ADVANCED(CMAKE_BACKWARDS_COMPATIBILITY CMAKE_INSTALL_PREFIX EXECUTABLE_OUTPUT_PATH
	LIBRARY_OUTPUT_PATH SLAM_P_P_DATA_PATH SLAM_P_P_SUPPLIED_LIBS_PATH)

SET(SLAM_P_P_SOURCE_DIR ${PROJECT_SOURCE_DIR})

# Path project-specific CMake modules.
SET(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/CMakeModules;${CMAKE_MODULE_PATH}")

# Set default build type (note this does not cause the cmake -i display line asking for this value, this just makes sure it is set)
IF(NOT CMAKE_BUILD_TYPE)
	SET(CMAKE_BUILD_TYPE "Release" CACHE STRING "Default build type." FORCE)
ENDIF(NOT CMAKE_BUILD_TYPE)

# support for GPU BLAS
IF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 2)
	OPTION(SLAM_P_P_GPU_BLAS "Use GPU acceleration for CHOLMOD." FALSE)
ENDIF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 2)

# offer solvers
SET(SLAM_P_P_LINEAR_SOLVER_TYPE 3 CACHE STRING "Linear solver type (0 = CSparse, 1 = CXSparse, 2 = CHOLMOD, 3 = native). Note that the new fast L only works with native.")

# try using cholmod with int instead of long
IF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 2)
	IF(CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
		OPTION(SLAM_P_P_SHORT_CHOLMOD "Use 32-bit indices for 64-bit CHOLMOD." FALSE)
	ENDIF(CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
	OPTION(SLAM_P_P_USE_METIS "Use the METIS library for CHOLMOD." FALSE)
ENDIF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 2)

# try using cholmod with int instead of long
IF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 1 AND CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
	OPTION(SLAM_P_P_SHORT_CXSPARSE "Use 32-bit indices for 64-bit CXSparse." FALSE)
ENDIF(SLAM_P_P_LINEAR_SOLVER_TYPE EQUAL 1 AND CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)

# explicitly ask about compiler flags
IF(UNIX)
	IF(APPLE)
		OPTION(SLAM_P_P_AGGRESSIVE_OPTIMIZATIONS "Use aggressive optimizations." FALSE)
	ELSE(APPLE)
		OPTION(SLAM_P_P_AGGRESSIVE_OPTIMIZATIONS "Use aggressive optimizations." TRUE)
	ENDIF(APPLE)

	SET(MY_CXX_FLAGS_RELEASE "-O3 -DNDEBUG" CACHE STRING "C++ compiler flags")
	SET(MY_C_FLAGS_RELEASE "-O3 -DNDEBUG" CACHE STRING "C compiler flags")

	# removed the following problematic flags: -ftemplate-depth=1024
	IF(SLAM_P_P_AGGRESSIVE_OPTIMIZATIONS)
		SET(MY_C_CXX_AGGRESSIVE_FLAGS "-ffast-math -funsafe-loop-optimizations -fprefetch-loop-arrays" CACHE STRING "C/C++ aggressive optimization compiler flags")
		SET(CMAKE_CXX_FLAGS_RELEASE "${MY_CXX_FLAGS_RELEASE} ${MY_C_CXX_AGGRESSIVE_FLAGS}")
		SET(CMAKE_C_FLAGS_RELEASE "${MY_C_FLAGS_RELEASE} ${MY_C_CXX_AGGRESSIVE_FLAGS}")
	ELSE(SLAM_P_P_AGGRESSIVE_OPTIMIZATIONS)
		SET(CMAKE_CXX_FLAGS_RELEASE "${MY_CXX_FLAGS_RELEASE}")
		SET(CMAKE_C_FLAGS_RELEASE "${MY_C_FLAGS_RELEASE}")
	ENDIF(SLAM_P_P_AGGRESSIVE_OPTIMIZATIONS)

	SET(MY_EXE_LINKER_FLAGS " " CACHE STRING "Linker flags")
	SET(CMAKE_EXE_LINKER_FLAGS "${MY_EXE_LINKER_FLAGS}")
ENDIF(UNIX)

# apply some OpenMP definmitions, make eigen not parallel
OPTION(SLAM_P_P_USE_OPENMP "Use OpenMP for parralelization." TRUE)
IF(SLAM_P_P_USE_OPENMP)
	FIND_PACKAGE(OpenMP)
	IF(OPENMP_FOUND)
		SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} ${OpenMP_C_FLAGS}")
		SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -DEIGEN_DONT_PARALLELIZE ${OpenMP_CXX_FLAGS}")
		SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${OpenMP_C_FLAGS}")
		SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DEIGEN_DONT_PARALLELIZE ${OpenMP_CXX_FLAGS}")
		MESSAGE(STATUS "Compiling with OpenMP support")
		# no linker flags set, the compiller will somehow pass it onto the linker automatically
	ELSE(OPENMP_FOUND)
		IF(APPLE)
			MESSAGE(STATUS "Compiling without OpenMP support (disabling OpenMP)")
			SET(SLAM_P_P_USE_OPENMP FALSE CACHE BOOL "Use OpenMP for parralelization." FORCE)

			mark_as_advanced(FORCE OpenMP_C_FLAGS)
			mark_as_advanced(FORCE OpenMP_CXX_FLAGS)
			# dont want to confuse the user with that
		ENDIF(APPLE)
	ENDIF(OPENMP_FOUND)
ENDIF(SLAM_P_P_USE_OPENMP)

# support SSE4 (good on Intel platforms)
OPTION(SLAM_P_P_USE_SSE4 "Use the SSE4 instruction set." TRUE)
IF(SLAM_P_P_USE_SSE4)
	IF(UNIX)
		SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -msse4")
		SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -msse4")
	ELSE(UNIX)
		ADD_DEFINITIONS(-DEIGEN_VECTORIZE_SSE3)
		ADD_DEFINITIONS(-DEIGEN_VECTORIZE_SSE4)
	ENDIF(UNIX)
ELSE(SLAM_P_P_USE_SSE4)
	# support SSE3 (good on Intel platforms)
	OPTION(SLAM_P_P_USE_SSE3 "Use the SSE3 instruction set." TRUE)
	IF(SLAM_P_P_USE_SSE3)
		IF(UNIX)
			SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -msse3")
			SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -msse3")
		ELSE(UNIX)
			ADD_DEFINITIONS(-DEIGEN_VECTORIZE_SSE3)
		ENDIF(UNIX)
	ENDIF(SLAM_P_P_USE_SSE3)
ENDIF(SLAM_P_P_USE_SSE4)

# find CUDA
OPTION(GPU_ENABLED "Use GPU acceleration for SLAM++." FALSE)
if(GPU_ENABLED)
	SET(CULA_FIND_REQUIRED TRUE)
	FIND_PACKAGE(CULA)
	# find CULA

	SET(CUDA_FIND_REQUIRED TRUE)
	FIND_PACKAGE(CUDA)
	# find CUDA

	mark_as_advanced(CUDA_BUILD_CUBIN)
	mark_as_advanced(CUDA_BUILD_EMULATION)
	mark_as_advanced(CUDA_CHECK_DEPENDENCIES_DURING_COMPILE)
	mark_as_advanced(CUDA_GENERATE_DEPENDENCIES_DURING_CONFIGURE)
	mark_as_advanced(CUDA_HOST_COMPILER)
	mark_as_advanced(CUDA_SEPARABLE_COMPILATION)
	mark_as_advanced(CUDA_SDK_ROOT_DIR)
	mark_as_advanced(CUDA_VERBOSE_BUILD)
	# average Joe doesn't need to know about those
	
	SET(CUDA_INCLUDE_IFENABLED ${CUDA_INCLUDE_DIRS} ${CULA_INCLUDE})
	SET(CUDA_LIBRARIES_IFENABLED ${CUDA_CUDA_LIBRARY} ${CUDA_cublas_LIBRARY}
		${CUDA_cusparse_LIBRARY} ${CULA_CULA_LIBRARY} ${CULA_lapack_LIBRARY})
	# requires libcuda.so / cuda.lib. cudart won't do.

	#message("includes: ${CUDA_INCLUDE_IFENABLED}")
	#message("libs: ${CUDA_LIBRARIES_IFENABLED}")
	# debug
ELSE(GPU_ENABLED)
	SET(CUDA_INCLUDE_IFENABLED "")
	SET(CUDA_LIBRARIES_IFENABLED "")
	ADD_DEFINITIONS(-D__DISABLE_GPU)
ENDIF(GPU_ENABLED)

# compile for native architecture, might run faster (less portable, is it?)
IF(UNIX AND NOT APPLE)
	OPTION(SLAM_P_P_USE_MARCH_NATIVE "Use native architecture (-march=native)." TRUE)
	IF(SLAM_P_P_USE_MARCH_NATIVE)
		SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -march=native")
		SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -march=native")
	ENDIF(SLAM_P_P_USE_MARCH_NATIVE)
ENDIF(UNIX AND NOT APPLE)

# Show make output print actualy executed commands?
OPTION(SLAM_P_P_VERBOSE_MAKEFILE "Verbose make output." "OFF")
IF(SLAM_P_P_VERBSOSE_MAKEFILE)
	SET(CMAKE_VERBOSE_MAKEFILE "ON")
ENDIF(SLAM_P_P_VERBSOSE_MAKEFILE)

# Linux platform specific flags and settings.
IF(UNIX)
	ADD_DEFINITIONS(-D_UNIX)
	IF(CMAKE_BUILD_TYPE STREQUAL "Debug")
		ADD_DEFINITIONS(-D_DEBUG)
		SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g -ggdb")
		SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g -ggdb")
		SET(CMAKE_LINK_FLAGS "${CMAKE_LINK_FLAGS} -lrt")
	ENDIF(CMAKE_BUILD_TYPE STREQUAL "Debug")
	IF(CMAKE_SIZEOF_VOID_P EQUAL 8)
		OPTION(SLAM_P_P_32BIT_BUILD "Build 32bit binaries on 64bit system." "OFF")
		IF(SLAM_P_P_32BIT_BUILD)
			SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32 -O3")
			SET(CMAKE_LINK_FLAGS "${CMAKE_LINK_FLAGS} -m32 -lrt")
		ENDIF(SLAM_P_P_32BIT_BUILD)
	ENDIF(CMAKE_SIZEOF_VOID_P EQUAL 8)
ELSE(UNIX)
	ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_DEPRECATE)
	IF(CMAKE_SIZEOF_VOID_P EQUAL 8)
		OPTION(SLAM_P_P_32BIT_BUILD "Build 32bit binaries on 64bit system." "OFF")
		IF(NOT SLAM_P_P_32BIT_BUILD)
			SET(CMAKE_CL_64 TRUE)
			# support for x64 builds using visual studio
		ENDIF(NOT SLAM_P_P_32BIT_BUILD)
	ENDIF(CMAKE_SIZEOF_VOID_P EQUAL 8)
ENDIF(UNIX)

# Set output path for libraries.
SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib CACHE PATH
	"Output directory for compiled libraries.")

# Set output path for binaries.
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin CACHE PATH
	"Output directory for compiled executables.")

# Set program data directory.
SET(SLAM_P_P_DATA_PATH ${CMAKE_INSTALL_PREFIX}/data CACHE PATH
	"Output directory program data.")

# set compiler output directories (not make install, just make)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)

# if doing 64-bit build, we need CAMD with both DLONG and NLONG to be able to run short CHOLMOD
IF(SLAM_P_P_SHORT_CHOLMOD AND CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
	SET(SLAM_P_P_LIBRARIES slampp_base csparse cxsparse camd_dlong cholmod eigen ${CUDA_LIBRARIES_IFENABLED})
	SET(SLAM_EXAMPLE_LIBRARIES slampp_base csparse cxsparse camd_dlong cholmod eigen ${CUDA_LIBRARIES_IFENABLED})
ELSE(SLAM_P_P_SHORT_CHOLMOD AND CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
	SET(SLAM_P_P_LIBRARIES slampp_base csparse cxsparse cholmod eigen ${CUDA_LIBRARIES_IFENABLED})
	SET(SLAM_EXAMPLE_LIBRARIES slampp_base csparse cxsparse cholmod eigen ${CUDA_LIBRARIES_IFENABLED})
ENDIF(SLAM_P_P_SHORT_CHOLMOD AND CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)

# Include project headers.
INCLUDE_DIRECTORIES(
  ${CUDA_INCLUDE_IFENABLED}
  ${PROJECT_SOURCE_DIR}/include/
  ${PROJECT_SOURCE_DIR}/external/Ceres/include/
  ${PROJECT_SOURCE_DIR}/external/Ceres/internal/
  ${PROJECT_SOURCE_DIR}/external/NIST_BLAS/include/
  ${PROJECT_SOURCE_DIR}/external/g2o/
  ${PROJECT_SOURCE_DIR}/include/cholmod/SuiteSparse/)

# Path to supplied dependency libraries.
IF(UNIX)
	IF(CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
		SET(SLAM_P_P_SUPPLIED_LIBS_PATH ${PROJECT_SOURCE_DIR}/lib/linux64
			CACHE STRING "Path to supplied dependency libraries.")
	ELSE(CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
		SET(SLAM_P_P_SUPPLIED_LIBS_PATH ${PROJECT_SOURCE_DIR}/lib/linux32
			CACHE STRING "Path to supplied dependency libraries.")
	ENDIF(CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT SLAM_P_P_32BIT_BUILD)
ENDIF(UNIX)

ADD_SUBDIRECTORY(include)
ADD_SUBDIRECTORY(src)
